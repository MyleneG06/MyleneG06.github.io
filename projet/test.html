<!DOCTYPE html>
<html>
  <head>
    <title>Compass</title>
    <style>
        html,body,#map { width:100%; height:100%; margin:0; }
        #map {position: absolute; z-index: 5;}
    </style>

  </head>
  
  <body>
    <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.9.0/build/ol.js"></script>
    <link href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.9.0/css/ol.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    
    <label>Info : </label><span id="accuracy"></span>  
<!-- INFOS COORDONNEES -->
    <label>Latitude : </label><span id="latitude"></span>        </br>
    <label>Longitude : </label><span id="longitude"></span>      </br>        
    <label>Altitude : </label><span id="altitude"></span>      </br></br>
<!-- BOUTONS RANDOS -->
    <button id="start">Démarrer</button><p id="startInfo"></p>	</br>
    <button id="stop">Arrêter</button> <p id="stopInfo"></p>	</br>
    <p id="stats"></p>	</br>
<!-- CARTE -->
    <div  id = "map"> </div>

    <script>
        var latitude = document.getElementById('latitude');
        var longitude = document.getElementById('longitude');
        var altitude = document.getElementById('altitude');
        let start = document.getElementById('start');
        let startInfo = document.getElementById('startInfo');
        let stop = document.getElementById('stop');
        let stopInfo = document.getElementById('stopInfo');
        let stats = document.getElementById('stats');
// Centrage de la carte autour des coordonnées représentées par l'icône et précisées dans le formulaire
        navigator.geolocation.watchPosition(function(pos) {
            const coordinates = geolocation.getPosition();
            // var moi = L.circle([pos.coords.latitude, pos.coords.longitude], {
			// 		color: 'blue',
			// 		fillColor: '#00f',
			// 		fillOpacity: 0.5,
			// 		radius: pos.coords.accuracy
			// 	}).addTo(map);
                document.getElementById('accuracy').innerHTML = pos.coords.accuracy;
            iconCar.setGeometry(coordinates ? new ol.geom.Point(coordinates) : null);
            if (map.getView() != null){map.getView().fit(iconCar.getGeometry(),{maxZoom: 20});}
            latitude.innerHTML = pos.coords.latitude;
            longitude.innerHTML = pos.coords.longitude;
            if(pos.coords.altitude != null) {altitude.innerHTML = pos.coords.altitude;}
            view.setCenter([pos.coords.longitude, pos.coords.latitude]);

// Récupération des données de départ et arrivée
stop.disabled = true;
            var distanceTot;
            var A;
            //var altitudeMax;
            //var altitudeMin;
            
            // start.addEventListener("click",function(){
            //     stop.disabled = false;
            //     start.disabled = true;
            //     A = pos.coords;
            //     //
            //     console.log("A : "  + A);
            //     startInfo.innerHTML = "Coordonnées de départ : " + A.altitude + "(m d'altitude) - " + A.latitude + "(lat) - " + A.longitude + "(lon)";
            //     distanceTot = 0;
            //     // altitudeMin = A.altitude;
            //     // console.log("altitude min : "  + altitudeMin);
            //     // altitudeMax = A.altitude;
            //     // console.log("altitude max : "  + altitudeMax);

// setInterval(function(){
//     var B = pos.coords;
// // On affiche le petit trajet parcouru en fonction du temps défini
//         var step = L.polygon([
//             [A.latitude, A.longitude], //point précédent
//             [B.latitude, B.longitude] //dernier point
//         ],
//         {
//             color: 'red',
//             fillColor: '#03f',
//             fillOpacity: 0.5,
//         }).addTo(map);
// // On met à jour la distance totale en km et les dénivelés
//         distanceTot += Math.round(findDistance(A,B)/1000);
//         if (altitudeMin>B.altitude) {altitudeMin = B.altitude}
//         if (altitudeMax<B.altitude) {altitudeMax = B.altitude}
// // On met les données du nouveau point sur l'ancien pour le calcul suivant
//         A = B;
//     }, 30000); // toutes les 30 secondes
			// });


// 				stop.addEventListener("click",function(){
// 					stop.disabled = true;
// 					start.disabled = false;

// 					stopInfo.innerHTML = "Horaire d'arrivée : " + Date() + "</br> Coordonnées : " + pos.coords.altitude + "(m d'altitude) - " + pos.coords.latitude + "(lat) - " + pos.coords.longitude + "(lon)";

// 					var B = pos.coords;
// 					var step = L.polygon([
// 						[A.latitude, A.longitude], //point précédent
// 						[B.latitude, B.longitude] //dernier point
// 					],
// 					{
// 						color: 'red',
// 						fillColor: '#03f',
// 						fillOpacity: 0.5,
// 					}).addTo(map);

// 					if (altitudeMin>B.altitude) {altitudeMin = B.altitude}
// 					if (altitudeMax<B.altitude) {altitudeMax = B.altitude}
// 					distanceTot += Math.round(findDistance(A,B)/1000);

// 					stats.innerHTML = "STATISTIQUES </br>Distance totale en km : " + distanceTot + "</br>Altitude entre " + altitudeMin + " et " + altitudeMax +"</br>(soit un dénivelé de : "+ (altitudeMax-altitudeMin)+").";

					//navigator.geolocation.clearWatch(surv);
				// });
            
        });

//initialisation des variables et affichage de la carte
        var rota_;
        var vectorSource = new ol.source.Vector(),
            url_osrm_nearest = '//router.project-osrm.org/nearest/v1/driving/',
            url_osrm_route = '//router.project-osrm.org/route/v1/driving/',
            icon_url = '//cdn.rawgit.com/openlayers/ol3/master/examples/data/icon.png',
            vectorLayer = new ol.layer.Vector({
                source: vectorSource
            }),
            styles = {
                route: new ol.style.Style({
                stroke: new ol.style.Stroke({
                    width: 6, color: [40, 40, 40, 0.8]
                    })
                }),
                icon: new ol.style.Style({
                    image: new ol.style.Icon({
                    anchor: [0.5, 1],
                    src: icon_url
                    })
                })
            };
        const view = new ol.View({center: [10,10], zoom: 50, projection: 'EPSG:4326'});
        const map = new ol.Map({ layers: [new ol.layer.Tile({source: new ol.source.OSM(),}), vectorLayer], target: 'map', view: view,});
        const geolocation = new ol.Geolocation({ trackingOptions: { enableHighAccuracy: true }, projection: view.getProjection(),});
        geolocation.setTracking(1);

//mise à jour de l'orientation de l'icône quand on change l'orientation du téléphone
        window.addEventListener("deviceorientation", handleOrientation, true);
        
//définition de l'icône de position
        const iconCar = new ol.Feature({ name: 'Null Island', population: 4000, rainfall: 500, size: [5, 5],});
        const iconStyle = new ol.style.Style({
        image: new ol.style.Icon({
            anchor: [0,5, 1],
            anchorXUnits: 'fraction',
            anchorYUnits: 'pixels',
            src: 'https://freeiconshop.com/wp-content/uploads/edd/location-arrow-solid.png',
            rotateWithView: "false",
            scale: 0.1,
            anchorXUnits: 'fraction',
            anchorYUnits: 'pixels',
        })        });
        iconCar.setStyle(iconStyle);
        new ol.layer.Vector({map: map, source: new ol.source.Vector({features: [iconCar],}),});

//Fonction récupérant l'orientation de la boussole        
        function compassHeading(alpha, beta, gamma) {
            var alphaRad = -alpha * (Math.PI / 180);
            var betaRad = beta * (Math.PI / 180);
            var gammaRad = gamma * (Math.PI / 180);
            betaRad = 1.5707963268;
            var cA = Math.cos(alphaRad);
            var sA = Math.sin(alphaRad);
            var cB = Math.cos(betaRad);
            var sB = Math.sin(betaRad);
            var cG = Math.cos(gammaRad);
            var sG = Math.sin(gammaRad);
            var rA = - cA * sG - sA * sB * cG;
            var rB = - sA * sG + cA * sB * cG;
            var rC = - cB * cG;
            var compassHeading = Math.atan(rA / rB);
            if(rB < 0) {
                compassHeading += Math.PI;
            }else if(rA < 0) {
                compassHeading += 2 * Math.PI;
            }
            return compassHeading;
        }

//Fonction modifiant l'affichage de la carte et de l'icône quand l'orientation change
        function handleOrientation(event) {
            absolute = event.absolute;
            alpha    = event.alpha;
            beta     = event.beta;
            gamma    = event.gamma;
            if(isNaN(rota_)) {
                rota_ = compassHeading(alpha, beta, gamma);
                //iconStyle.getImage().setRotateWithView(1);
            }else{
                eski_yon = rota_;
                rota_ = compassHeading(alpha, beta, gamma);   
            }
            if(rota_ != null && !isNaN(rota_)) {
                //iconStyle.getImage().setRotateWithView(0);
                map.getView().setRotation(rota_);
            }
            view.setCenter([longitude.innerHTML,latitude.innerHTML]);
        }
        

    </script>
  </body>
</html>